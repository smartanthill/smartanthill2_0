..  Copyright (c) 2015, OLogN Technologies AG. All rights reserved.
    Redistribution and use of this file in source (.rst) and compiled
    (.html, .pdf, etc.) forms, with or without modification, are permitted
    provided that the following conditions are met:
        * Redistributions in source form must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in compiled form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
        * Neither the name of the OLogN Technologies AG nor the names of its
          contributors may be used to endorse or promote products derived from
          this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL OLogN Technologies AG BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGE

.. _sasp:

SmartAnthill Security Protocol (SASP)
=====================================

:Version:   v0.1.3

*NB: this document relies on certain terms and concepts introduced in*
:ref:`saoverarch` *and*
:ref:`saprotostack` *documents, please make sure to read them before proceeding.*

SASP (SmartAnthill Security Protocol) aims to provide security guarantees for communications within SmartAnthill environments, in particular, prevention from unauthorized access to message content, message integrity guarantees, and protection from replay attacks.

.. contents::

1. Definitions
--------------

1.1. **Packet**. A unit of data exchange with other levels/protocols. For the sake of clarity two types of packets are distinguished:

     * **HLP packet**: a packet that is sent to or received from a higher-level protocol. HLP packet data is a payload for SASP, as it will be discussed in more details below.
     * **SASP packet**:  a packet that is formed by SASP and is sent to or received from the communication peer (using an underlying protocol).
     * **Internally valid SASP packet**: a packet that has passed authentication based solely on packet data (see also packet-based authentication).

1.2. **SASP Packet structure**

SASP packet structure looks as follows:

**\| SASP Header \| Security Tag \| Data Under Encryption \|**

where:

  * **SASP Header** is a non-encrypted part of the packet that contains flags and certain bits of the packet nonce. Header takes 6 bytes.
  * **Security Tag**: data related to encryption and authentication process. Security Tag takes 16 bytes.
  * **Data Under Encryption**: encrypted data, which includes certain SASP information as well as SASP payload.

1.3. **Packet Nonce**: all data used as a packet nonce for purposes of encryption/authentication. PFN consists of: 

     * **Nonce Varying Part (Nonce VP)**: a fixed-size bit sequence uniquely generated by a sending device for each new packet; Nonce VP is 47 bits.
     * **Destination Flag**: a bit that indicates whether the packet is intended solely to SASP itself (such as a packet with Error "Old Nonce" Message), or for its higher level protocol.
     * **Peer-Distinguishing Flag**: a bit that is set to 0 for one communication peer and to 1 for another peer.

1.4. **Nonce Lower Watermark (NLW)**: a value supported by a packet receiving side that is used to determine whether a value of Packet Nonce VP (i) has never been used before (if a new packet is received); (ii) has been used with the last received packet (for instance, in case of packet resending); or (iii) a de-synchronization in communication has happened.

1.5. **Nonce to use For Sending (NFS)**: a value supported by a packet sending side that is used to generate a value of Packet Nonce VP that would have never been used before, and that would be verifiable by the communication peer.

1.6. **Last Received Packet Signature**: [+++check whether it is indeed required]

1.7. **Packet validation process**: a core task of SASP main purpose of which is to ensure that a packet is actually received is from an intended communication partner, is not modified by a third party on the way, and its content (unless specified otherwise) is protected from reading by not indented parties. On the sending side of communication the packet validation process results in encryption and adding authentication data. On receiving side a process can logically be divided into two steps:

  * **packet-based authentication**, which is done using solely packet data such as respective headers, nonces, tags, etc, and not using NLW;
  * **in-sequence authentication**, which is based on comparison of a packet nonce Varying Part with the Nonce Lower Watermark.

1.8. **Error "Old Nonce" Message**: a packet that represents an "old nonce" error report with the lowest possible value of a valid nonce VP (which is equal to a current value of Nonce Lower Watermark plus 1). This packet can be sent, if an otherwise valid packet is received with an "old" nonce VP, that is, with a nonce VP that is less than the Nonce Lower Watermark.



2. Security choices
-------------------

The core of SASP is packet encryption/decryption and authentication. These processes are based on  EAX algorithm (see [EAX]_). Design choices with respect the above-mentioned algorithm are:

  * Encryption method: AES-256
  * Tag size: 128 bit
  * EAX Nonce size: 49 bit, in particular:
     
     * Nonce Varying Part: 47 bit [1]_
     * Destination Flag: 1 bit
     * Peer-Distinguishing Flag: 1 bit

To reduce the amount of data transferred, Peer-Distinguishing Flag is not actually transferred but just appended to the packet header that actually contains only Nonce Varying Part and Destination Flag to get a Packet Full Nonce:

  * SASP Header size: 48 bit, in particular:
     
     * Nonce Varying Part: 47 bit
     * Destination Flag: 1 bit

**Rationale**: In order to use the same encryption key in both directions of communication each nonce should be unique for packets going in both directions, too. Uniqueness of the nonce going in a particular direction is enforced by packet sender (using nonce VP generation based on NFS). To separates sets of nonces generated by each of two communication peers, a separate bit in the nonce value (Peer-Distinguishing Flag) is used to distinguish between peers so that this bit is set for all nonces generated by one peer and is not set for nonces generated by the other peer. Which peer should have this bit set can be determined, in particular, during set up of communication between two specific devices (for instance, at the same time when encryption key exchange is done), or can be a predefined choice for some types of the devices, if devices of different type participate in communication (for instance, in communication of a Master device with a Slave device Master device may always have the flag set, and Slave device may always have the flag not set).

.. [1] If 47 bit nonce VP is used, then different nonces will be enough for 10 years with packet frequency of 2.25 mks: 10*365*24*60*60*1000000/2^47 = 2.25


2.1 SASP Nonces
^^^^^^^^^^^^^^^

In SASP, nonce varying part is always increased, and never goes back. This is a critical requirement for SASP to be secure (both to guarantee nonce being unique, which is required for EAX to be secure, and to avoid replay attacks).


3. Security Guarantees
----------------------

Security of SASP relies on security of EAX, which is proven as long as underlying cipher (AES128) is secure, and as long as nonces are unique per key. 

Within SASP, keys MUST be unique for each communication pair, and uniqueness of nonces for the pair is guaranteed by:

* Peer-Distinguishing Flag
* for packets sent by each peer, by "Nonce to use for Sending" (NFS)

EAX as such doesn't guarantee protection from replay attacks, however as nonces are unique, replay attack is not possible as long as SASP drops packets with repeated nonces. SASP does drop packets with repeated nonces, with two exceptions:

* last packet being re-sent is not being dropped by SASP (it can be a legitimate retransmit which may require retransmit in return) but is reported as 'repeated packet' to higher-level protocol; this is not a security problem as long as the only action higher-level protocol does on receiving it, is re-sending the very last packet it has already sent. SAGDP does satisfy this requirement.
* Error "Old Nonce" Message. For 'Error "Old Nonce" Message, SASP does not check the nonce (this is necessary to avoid potential deadlocks). However, replay attack based on these messages is not possible, because SASP does not allow NLW to decrease, and therefore all replay packets will be ignored by SASP.

Therefore, SASP is secure (because of EAX and AES128 being secure) and also provides protection from replay attacks.

4. Scenarios
------------

4.1. Normal packet processing
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Two devices, A and B, participate in packet exchange. Each packet sent is encrypted and authenticated in a way to both guarantee packet integrity and protect from replay attacks. Each packet received has a respective authentication data. Correspondingly, when an HLP packet is being prepared for sending, it is encrypted by an encryption key known to both communication peers, and authentication data is added. It is important that a nonce used for encryption/authentication could be recognized as such (that is, as a value actually used once) by the other communication peer. This is achieved by using Nonce to use For Sending (NFS) on the sending side and Nonce Lower Watermark (NLW) on receiving side.

4.1.1. How NFS / NLW pair works
'''''''''''''''''''''''''''''''

To avoid replay attacks nonces are commonly used to distinguish between an original message and a message with otherwise the same content that is being replayed. A problem with nonces is to check that a particular value is actually new and has not yet been used ever before. To address this problem SASP treats VP of nonces as numerical values and compares a nonce VP from a received packet with a current value of the NLW. If the value of nonce VP is greater than a current value of the NLW, the nonce is considered as new; in this case the value of NLW is set to the value of the nonce VP, and its reuse becomes impossible.

To be economical with the set of values that are greater than a current value of NLW (within a certain range), it is desired that a value of a new nonce VP received be as close (from above) to NLW as possible, ideally, greater by 1. NFS is used to keep track of nonces on the sending side. Initially (for example, at the same time when secret keys are exchanged between the sides) communication partners set NLW on receiving side to the same value as NFS on sending side (namely, NLW = 0, and NFS = 0). Before a new packet is being sent, NFS is incremented, and packet nonce VP is set to a value of NFS. On the receiving side, upon reception of the packet, the value of NLW will become the value of the nonce VP, that is, again equal to NFS on the sending side. The process may be continued until all space of NFS/NLW values is exhausted.

TODO: Nonce Exhaustion/Overflow handling

4.2. Processing repeated Packet
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In some cases it may be desired to repeat resending the same packet. For instance, it may be detected that a packet has not been received by the communication peer. In this case an exact copy of the packet is re-sent; being exact copy implies that the packet has the same nonce as the original packet. On the receiving side the nonce VP is found to be equal to NLW (since NLW was set to the value of nonce VP of the original packet). SASP detects this special case, and, if the packet is otherwise valid, reports that the packet is repeated to the higher level protocol while passing the packet for further processing.

4.3. Processing packet with an obsolete nonce
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If a packet is internally valid, but its nonce VP is less than a current value of NLW, it may indicate that states of the communication peers are out of sync (and not necessarily that a third party attack is detected). In this case, to resynchronize communication process an Error "Old Nonce" Message is formed with the lowest possible nonce VP, and a packet with this message is sent to a communication partner.

If an Error "Old Nonce" Message is received, the receiving party compares its NFS with the lowest possible value of the nonce within the message, and if NFS is less that value, NFS is set to the value as specified in the message; using such a value of NFS for sending packets will ensure that the packet will pass NLW test at the receiving party.

TODO: exact format of 'Error "Old Nonce" Message'


5. SASP padding
---------------

5.1. SASP Encoded-Size
^^^^^^^^^^^^^^^^^^^^^^

SASP Encoded-Size is a variable-length encoding of sizes (with the idea being somewhat similar to the idea behind UTF-8; it is also identical to the Yocto VM Encoded-Size as described in
:ref:`sayoctovm` ). Namely:

* if first byte of Encoded-Size is c1 <= 127, then the value of Encoded-size is equal to c1
* if first byte of Encoded-Size is c1 >= 128, then the next byte c2 is needed:

  + if second byte of Encoded-Size is c2 <= 127, then the value of Encoded-Size is equal to *128+((uint16)(c1&0x7F) | ((uint16)c2 << 7))*.
  + if second byte of Encoded-Size is c2 >= 128, then SASP receiving side MUST treat such a packet as an invalid (as the one which didn't pass internal validation). c2 >= 128 is reserved for potential future expansion)


The following table shows how many Encoded-Size bytes is necessary to encode ranges of Encoded-Size values:

+--------------------+---------------------+
| Encoded-Size Values| Encoded-Size Bytes  |
+====================+=====================+
| 0-127              | 1                   |
+--------------------+---------------------+
| 128-16511          | 2                   |
+--------------------+---------------------+

**Note 1**: it should be evident that this encoding contains both an addressed size and the size used for storing encoded value. [TODO: ?]

**Note 2**:  upon necessity this encoding can be extended by analogy to address greater sizes.

**Note 3**:  unless "enforced padding" (see below) is used, SASP pads data only to the block size; it means that unless "enforced padding" is used, padding size is always <= 15, and therefore Encoded-Size cannot be longer than 1 byte.

5.2. SASP data under encryption and payload
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SASP data under encryption is organized as follows:

\| **First Byte** \| (opt) **padding size** \| **byte sequence** \| (opt) **padding** \|

where:

  * **First Byte** is a 1 byte field that is treated as follows:

     * **MSB bit**: padding size flag, which is set to 1, if padding is present, and 0 otherwise. Presence of padding implies presence of padding size field as well.
     * **Remaining 7 bits**: a part of payload.

  * **padding size**: variable size field; this field is present only if padding size flag is set; in this case the field contains encoded padding size; the size of the field can be derived from the field data itself (see SASP Encoded size for details).
  * **byte sequence**: variable size field; data that is defined by a higher level protocol.
  * **padding**: variable size field; this field is present only if padding size flag is set; contains padding up to a target size.
  
Correspondingly, SASP payload consists of:

  * **Remaining 7 bits of the First Byte**
  * **byte sequence**

Higher-level protocol is free to use "partial byte" (7 bits) of SASP payload, or to ignore it; however, this "partial byte" might be useful, for example, to store some bitflags of higher-level protocol, which may allow to save 1 byte of payload.
  
5.3. SASP padding data
^^^^^^^^^^^^^^^^^^^^^^

If present, padding data SHOULD be generated randomly. Depending on capabilities of the implementing device, upon necessity, this requirement MAY be relaxed. [TODO: describe approach with generating pseudorandom data using an independent encryption key and a current nonce]

5.4. SASP enforced padding
^^^^^^^^^^^^^^^^^^^^^^^^^^

In certain scenarios, some information might be extracted from the packet length even though information is encrypted. To support the cases when this is important, SASP supports a concept of "enforced padding", which works as follows:

* When sending a packet, a high-level protocol is allowed to specify size of 'enforced padding'. On receiving such a request, SASP:

  + checks if, given the size of the packet itself, 'enforced padding' can be satisfied (i.e. that packet is small enough to fit into requested 'enforced padding'); if 'enforced padding' is requested and cannot be satisfied - it MUST cause an error to be returned back to high-level protocol, without further processing of the packet at ll.
  + pads packet up to requested 'enforced padding'

6. SASP data
------------

For its operations SASP uses the following data:

- Nonce Lower Watermark (NLW)
- Nonce to use For Sending (NFS)
- Last Received Packet Signature (LRPS)


7. Events
---------

There are three events that SASP processes: 

 1. receiving a SASP packet from the communication peer
 2. receiving a packet  from a higher level protocol (HLP packet) where high-level protocol specifies it is a New packet, and
 3. receiving a packet  from a higher level protocol (HLP packet) where high-level protocol specifies it is a Repeated packet.

7.1. Receiving an HLP packet as New
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A packet from a higher level protocol is received with a status "New". After this packet is encrypted and authentication data is added using a new nonce, a resulting SASP packet is to be passed to the communication peer (using underlying protocol).

7.2. Receiving an HLP packet as Repeated
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A packet from a higher level protocol is received with a status "Repeated". In this case SASP MUST ensure that the SASP packet which it sends, is exactly the same as the previous packet. It MAY be achieved using any of the following:

* SASP itself keeps a copy of the previous packet, and validates that the one received from higher level protocol, is the same as the previous one
* higher-level protocol keeps a copy of the previous packet, and guarantees to SASP that it is the same packet as the previous one; in this case SASP MAY generate the SASP packet, based on the packet from higher-level protocol, and using [TODO:NFS or NFS-1?] as nonce.

7.3. Receiving a SASP packet
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A SASP packet from the communication peer is received (via underlying protocol). A packet can be:

  * valid new packet, which means that the packet data passed validation process, and packet nonce VP is greater than the Nonce Lower Watermark;
  * valid repeated packet, a copy of the last received packet;
  * old-nonce packet, an otherwise valid packet with a nonce VP less than the Nonce Lower Watermark, which means either de-synchronization in communication, or an attack attempt
  * packet with Error "Old Nonce" Message (intended for SASP itself)
  * invalid packet, in particular, corrupted, an attacker's packet, etc.




8. Event processing
-------------------

To process events the protocol should be in either "idle" state Details of processing are placed below.

8.1. Receiving an HLP packet as New
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NFS is incremented. HLP packet is encrypted and authenticated using current value of NFS to form a SASP packet. This SASP packet is sent to the communication peer using underlying protocol.

8.2. Receiving an HLP packet as Repeated
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

HLP packet is encrypted and authenticated using current value of NFS, that is, with a value that has been used while the original packet was sent. This SASP packet is sent to the communication peer using underlying protocol.


8.3. Receiving a SASP packet
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

On receipt of a SASP packet, first, a packet-based authentication is performed as follows:

* TODO!

Then:

  * if packet-based authentication has failed: the packet is silently dropped as being either corrupted or an attacker's packet;
  * if packet-based authentication is passed: it can be either an error message packet directed to SASP itself, or a "regular" packet with payload intended for a higher level protocol.

     + if a packet is with Error Old Nonce Message [+++structure and detection]: packet nonce VP is not compared to NLW (reason: replay attack is impossible since NFS cannot be decreased as a result of this message, and performing comparison may lead to a deadlock); a value of the lowest possible valid nonce from the packet is compared to the current value of NFS.

         * if NFS is less than the value of the lowest possible valid nonce: NFS is set to the value of the lowest possible valid nonce.
         * if NFS is greater than or equal to the value of the lowest possible valid nonce: no changes to NFS is done; the packet is ignored.

     + if packets other than Error Old Nonce Message: packet nonce VP is compared to the Nonce Lower Watermark (NLW). Three cases are possible:

        * if nonce VP is less than NLW: a packet with Error Old Nonce Message is prepared with the lowest possible valid nonce set to a current value of NLW; the packet is authenticated and sent to the communication peer.
        * if nonce VP is equal to NLW: a repeated packet is received: packet signature is compared to LRPS.

            + if packet signature is not equal to LRPS: a potential for an attacker's packet; the packet is silently dropped;
            + if packet signature is equal to LRPS: an HLP packet with payload of the received packet is passed to the higher level protocol with status "repeated"

        * if nonce VP is greater than NLW: a new packet is received: NLW is set to the value of nonce VP of the received packet; LRPS is set to packet signature; an HLP packet with payload of the received packet is passed to the higher level protocol with status "new".


9. Payload Size and SASP Packet Size
------------------------------------

As SASP is using 48-bit (= 6 bytes) nonce, a block cipher (AES128) with a block size of 128 bits (=16 bytes), and tag size is chosen as maximum 128 bits, it means that SASP packet size is always *(6+16+k\*16)=(22+k\*16)*, where *k >= 1*. 

The following table shows relations between SASP packet sizes and SASP payload [2]_ not including "remaining 7 bits" part (that is, a size of byte sequence part only):

+-------------------------+----------------------------------+
| SASP packet size, bytes | SASP payload, bytes              |
+=========================+==================================+
| 38                      |  7bits+0bytes to 7bits+15bytes   |
+-------------------------+----------------------------------+
| 54                      | 7bits+16bytes to 7bits+31bytes   |
+-------------------------+----------------------------------+
| 70                      | 7bits+32bytes to 7bits+47bytes   |
+-------------------------+----------------------------------+
| 86                      | 7bits+48bytes to 7bits+63bytes   |
+-------------------------+----------------------------------+
| 102                     | 7bits+64bytes to 7bits+79bytes   |
+-------------------------+----------------------------------+
| 118                     | 7bits+80bytes to 7bits+95bytes   |
+-------------------------+----------------------------------+

.. [2] Note that *SASP payload* is not the same as, say, *SAGDP payload* or *SACCP payload*: for example, if SAGDP lies right on top of SASP, then *SAGDP_Payload = SASP_Payload - Size_of_SAGDP_Headers*.




10. Implementation notes
------------------------

10.1 Incrementing nonces
^^^^^^^^^^^^^^^^^^^^^^^^

For SASP security, it is critical that nonces are never re-used and are always incremented (never going back). Therefore, implementation MUST enforce it (both for sending side and for receiving side).

10.1.1 Basic Implementation
'''''''''''''''''''''''''''

Basic secure implementation is rather simple:

* Whenever a new packet is sent, an update value of NSF MUST be **saved and committed in in persistent storage**; this commit MUST be performed **before** the packet is actually sent over the air. This is necessary to keep EAX security guarantees.
* Whenever a packet with status "new" is received, an updated value of NLW MUST be **saved and committed in persistent storage**; this commit MUST be performed **before** further message processing. This is necessary to avoid using an obsolete value of NLW in case of "dirty" reboot (and thus to avoid a potential for replay attacks). 

10.1.2 Optimized Implementation
'''''''''''''''''''''''''''''''

In cases where basic secure implementation is too resource-intensive (causing too many writes to persistent storage, which can be undesirable, in particular for EEPROM), the following optimizations MAY be used without affecting security; note that **implementation described below are ok if and only if all of the steps are implemented** (or none is implemented, falling back to the basic schema described above): [TODO: check that boundary handling ('<' vs '<=' etc. etc.) is described correctly]

* On program start:

  + both NSF and NLW are read from the persistent storage, and stored into the RAM (as 'Current_NSF' and 'Current_NLW' respectively). 
  + both NSF and NLW in persistent storage are incremented by a certain value DELTA; this change MUST be committed to persistent storage **before** any further processing. The value of DELTA can be, for example, 100; DELTA SHOULD NOT be too large, as having it too large, combined with frequent "dirty" reboots, may cause exhaustion of nonce space. 
  + These incremented values are also stored in RAM (as 'Last_NSF' and 'Last_NLW').

* Whenever a new value of NSF is needed (for the reasons stated above), if 'Current_NSF' is less than 'Last_NSF', then new value of NSF is taken as 'Current_NSF' and 'Current_NSF' is incremented in RAM. This is ok from security perspective, because in case of "dirty reboot" NSF will be still increased, and never repeated.
* Whenever a new value of NSF is needed (for the reasons stated above), and if 'Current_NSF' is greated or equal than 'Last_NSF', then:

  + NSF in persistent storage is incremented by DELTA (or other similar value); this new value MUST be committed to persistent storage before proceeding further
  + 'Last_NSF' is set to new value of NSF in persistent storage
  + 'Current_NSF' is returned as the new NSF value, and then incremented

* Whenever a new value of NLW is needed (for the reasons stated above), if 'Current_NLW' is less than 'Last_NLW', then new value of NLW is taken as 'Current_NLW' and 'Current_NLW' is incremented in RAM. This is ok from security perspective, because in case of "dirty reboot" NLW will be still increased, and never repeated. Using such policy for NLW might cause an extra 'Error "Old Nonce" Message', but this situation will be quickly recovered from.
* Whenever a new value of NLW is needed (for the reasons stated above), and if 'Current_NLW' is greated or equal than 'Last_NLW', then:

  + NLW in persistent storage is incremented by DELTA (or other similar value); this new value MUST be committed to persistent storage before proceeding further
  + 'Last_NLW' is set to new value of NLW in persistent storage
  + 'Current_NLW' is returned as the new NLW value, and then incremented


10.1.3 Restoring from Backup
''''''''''''''''''''''''''''

Whenever an entity-implementing-SASP (such as "SmartAnthill Central Controller") is restored from backup, it MUST take care to avoid duplicate nonces, in particular:

* amount of time dT (in seconds) between backup and restore MUST be calculated
* if dT is less than *min-backup-restore-time*, it MUST be set to *min-backup-restore-time*; normally *min-backup-restore-time* should be set to a value such as 24 hours.
* if dT is larger than *max-backup-restore-time*, restore SHOULD be interrupted, the problem SHOULD be explained to the person who's performing restore, and confirmation SHOULD be obtained before proceeding. This is intended to prevent restores with erroneous clock, which might lead to the erroneous exhaustion of the nonce space. Normally, *max-backup-restore-time* should be set to a value such as 30*24 hours.
* both NLW and NSF, as stored in persistent storage, MUST be increased by a number equal to: *dT\*max_number_of_packets_per_second*. This increased number **MUST be stored and committed to persistent storage before proceeding further**. Here, *max_number_of_packets_per_second* is a constant estimating maximum feasible number of packets which might be sent per second; in general, it depends on the higher-level protocols, but for basic SACCP it usually can be taken between 100'000 (1e5) and 1'000'000 (1e6). 

References
----------

.. [EAX] "The EAX Mode of Operation", http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf

